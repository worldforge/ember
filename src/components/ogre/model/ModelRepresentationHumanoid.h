/*
 Copyright (C) 2014 Céline NOËL <celine.noel.7294@gmail.com>

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifndef MODELREPRESENTATIONHUMANOID_H_
#define MODELREPRESENTATIONHUMANOID_H_

#include "ModelRepresentation.h"


namespace Ember
{
class SmartBodyManager;
class SmartBodyRepresentation;

namespace OgreView
{
class Scene;

namespace Model
{

class ActionDefinition;
struct SoundDefinition;
class Model;

/**
 @brief A model representation that is specialized for humanoid character.

 The common animations (locomotion, gestures, ...) are generated by SmartBody library.

 @author Céline NOEL <celine.noel.7294@gmail.com>

 */
class ModelRepresentationHumanoid: public ModelRepresentation
{
public:

	/**
	 * @brief Ctor.
	 * @param entity The entity instance to bind to.
	 * @param model The model instance used.
	 * @param scene The scene to which the entity belongs.
	 * @param mapping The model mapping tied to the model.
	 * @param sbManager A pointer to the SmartBody Manager.
	 */
	ModelRepresentationHumanoid(EmberEntity& entity, Model& model, Scene& scene, EntityMapping::EntityMapping& mapping, SmartBodyManager& sbManager);

	/**
	 * @brief Dtor.
	 */
	virtual ~ModelRepresentationHumanoid();

	/**
	 * @brief The two following return the name of this class.
	 */
	const std::string& getType() const;
	static const std::string& getTypeNameForClass();

	/**
	 * @return false if the model is animated manually with SmartBody, true otherwise.
	 */
	bool isOgreAnimated() const;

	/**
	 * @brief Gets the global translation value of the model since the last frame.
	 */
	const Ogre::Vector3& getTranslation() const;

	/**
	 * @brief Gets the rotation applied on the model relatively to (1, 0, 0, 0) quaternion.
	 */
	const Ogre::Quaternion& getRotation() const;

	/**
	 * @brief Reinitialize the transformation values of mCharacter (this must be done after the scene node has been positionned, not to 
	 * count the same translation, or rotation twice).
	 */	
	void reinitializeTransformation();

	/**
	 * @brief Returns true if the ModelHumanoidAttachment can use the values of translation and rotation.
	 */
	bool isTransformationInitialized() const;

	/**
	 * @brief Allows to know if the character is moving, to know if we need to update the position of the scene node (for example, if the
	 * character is in the idling posture, the position should not be updated, but in the case of a humanoid character, the translation 
	 * from walking to idling posture is not instantaneous, so we have to update it as long as the model is not entirely still).
	 */
	bool isMoving() const;
	

protected:

	/**
	 * @brief The corresponding SmartBody character.
	 */
	SmartBodyRepresentation *mCharacter;

	/**
	 * @brief A reference to the SmartBodyManager.
	 */
	SmartBodyManager& mSbManager;

	/**
	 * @brief The type name for the class.
	 */
	static std::string sTypeName;

	/**
	 * @brief Overriden from ModelRepresentation.
	 */
	void setIdleAnimationTime();

	/**
	 * @brief Overrides model_Reloaded_der in ModelRepresentation.
	 */
	void model_Reloaded_der();

	/**
	 * @brief Creates the character representation in SmartBody.
	 */
	void createSmartBodyCharacter();

	/**
	 * @brief Sets the animation corresponding to the given action.
	 */
	void setAnimation(const std::string& actionName, Action *newAction);
};

}
}
}
#endif /* MODELREPRESENTATION_H_ */
